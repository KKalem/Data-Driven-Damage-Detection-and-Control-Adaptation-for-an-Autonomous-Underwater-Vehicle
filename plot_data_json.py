#! /usr/bin/env python3
# -*- coding: utf-8 -*-
# vim:fenc=utf-8

import numpy as np
import time
import sys
import json

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D #needed for '3d'

import sklearn.preprocessing as pre

# better 3d scatter
from toolbox import plotting as pltn


def map_to_01(abs_max, v):
    r = v/abs_max # in -1,1
    r += 1 # in 0,2
    r /= 2 # in 0,1
    return r

def colorize_u(u,
               alpha=0.5,
               rudder_range=0.6,
               elevator_range=0.6,
               thruster_range=4000):
    colors = []
    for ru,el,t1,t2 in u:
        # rgba
        red = map_to_01(rudder_range, ru)
        green = map_to_01(elevator_range, el)
        blue = map_to_01(thruster_range, t1-t2)
        c = (red, green, blue, alpha)

        colors.append(c)

    colors = np.array(colors, dtype=float)
    return colors

def colorize_labels(labels):
    unique_labels = np.unique(labels)
    num_labels = len(unique_labels)
    color_steps = np.linspace(0.2,1, num_labels)
    colors = []

    handpicked_colors = [
        (1, 0, 0),
        (0, 1, 0),
        (1, 1, 0),
        (1, 0, 1),
        (0, 1, 1),
        (1, 1, 1)
    ]
    def colorize(label):
        selection = np.where(unique_labels==label)[0][0]

        if num_labels < len(handpicked_colors):
            return handpicked_colors[selection]

        r = color_steps[selection]
        g = color_steps[int(np.cos(selection)%len(color_steps))]
        b = color_steps[-int(np.cos(selection)%len(color_steps))]
        return r,g,b

    for label in unique_labels:
        print("label {} color {}".format(label, colorize(label)))

    for label in labels:
        r,g,b = colorize(label)
        colors.append((r,g,b,0.8))

    return np.array(colors, dtype=float)




def plot_xyz(xyz,
             u=None,
             win=None,
             highlight_indices=None,
             highlight_point=None,
             sizes=None,
             use_data_ranges=False,
             labels=None,
             colors=None):
    """
    xyz.shape == (N,3), u.shape == (N,), highlight_indices.shape == (K,), highlight_point.shape == (3,)
    """


    app = None
    if win is None:
        win, app = pltn.make_opengl_fig(grid_scale = (0.1,0.1,0.1))

    if colors is None:
        if labels is None:
            if u is None:
                colors = np.array([[1.0, 1.0, 1.0, 0.5]]*len(xyz))
            else:
                if use_data_ranges:
                    print("Colorizing with data ranges")
                    rr = max([abs(min(u[:,0])), abs(max(u[:,0]))])
                    er = max([abs(min(u[:,1])), abs(max(u[:,1]))])
                    t1r = max([abs(min(u[:,2])), abs(max(u[:,2]))])
                    t2r = max([abs(min(u[:,3])), abs(max(u[:,3]))])
                    tr = max([t1r, t2r])
                    print(f"rr={rr}, er={er}, tr={tr}")
                    colors = colorize_u(u, rudder_range=rr, elevator_range=er, thruster_range=tr)
                else:
                    colors = colorize_u(u)
        else:
            colors = colorize_labels(labels)

    if sizes is None:
        sizes = 1.5*np.ones(len(xyz))

    scatter = pltn.gl_scatter3(w=win, pts = xyz, size=sizes, color=colors)
    # looks fancy but impossible to understand anything from :D
    # pltn.gl_line3(w=win, pts=xyz, color=colors)

    if highlight_point is not None:
        pltn.gl_line3(w = win,
                      pts = [ (highlight_point[0], highlight_point[1], highlight_point[2]+10), highlight_point[:3] ])

    if highlight_indices is not None and len(highlight_indices)>0:
        highlight_colors = np.array([(1., 0., 0., 1.)]*len(xyz[highlight_indices]), dtype=float)
        highlight_sizes = 10*np.ones(len(xyz[highlight_indices]))
        pltn.gl_scatter3(w = win,
                         pts = xyz[highlight_indices],
                         size = highlight_sizes,
                         color = colors[highlight_indices])

    return win, app



class Dataset:
    def __init__(self, filename, keep_underwater_only=True, normalize_u=True):
        print("Loading {}".format(filename))
        if ".json" not in filename:
            print("Must pass a json file, generated by process_log")
            sys.exit(0)

        with open(filename, 'r') as f:
            data = json.load(f)
        print("Done")

        self.x = np.array(data['x'], dtype=float)
        self.xdot = np.array(data['xdot'], dtype=float)
        self.u = np.array(data['u'], dtype=float)
        self.t = np.array(data['t'], dtype=float)
        self.fields = data['fields']
        self.source_log = data['source_log']

        if normalize_u:
            np.clip(self.u[:,:2], -0.6, 0.6, out=self.u[:,:2])
            np.clip(self.u[:,2:], -500, 500, out=self.u[:,2:])
            # most common motion is forward, center on that...
            self.u[:,0] -= np.median(self.u[:,0])
            self.u[:,1] -= np.median(self.u[:,1])
            self.u = pre.maxabs_scale(self.u)

        self.accels = self.xdot[1:] - self.xdot[:-1]
        self.x = self.x[:-1]
        self.xdot = self.xdot[:-1]
        self.u = self.u[:-1]
        self.t = self.t[:-1]

        self.applied_mask = None

        if keep_underwater_only:
            underwater_inds = self.x[:,2] < -2
            self.filter(underwater_inds)

        self.original_accels = np.copy(self.accels)
        self.original_x = np.copy(self.x)
        self.original_xdot = np.copy(self.xdot)
        self.original_u = np.copy(self.u)
        self.original_t = np.copy(self.t)


    def get_maneuver(self, man_ind):
        print("get_maneuver assumes u's are normalized")
        turning_sens = 0.25
        straight_sens = 0.05
        maneuvers = [
            (-1, -1, turning_sens),
            (-1, 0, turning_sens),
            (-1, 1, turning_sens),
            (0, -1, turning_sens),
            (0, 0, straight_sens),
            (0, 1, turning_sens),
            (1, -1, turning_sens),
            (1, 0, turning_sens),
            (1, 1, turning_sens)
        ]
        rudder_target, elev_target, sens = maneuvers[man_ind]

        rudder_upper = min(1, rudder_target+sens)
        rudder_lower = max(-1, rudder_target-sens)

        elev_upper = min(1, elev_target+sens)
        elev_lower = max(-1, elev_target-sens)

        # get the parts that match the maneuver we're interested in
        rudder_mask = np.logical_and(self.u[:,0] <= rudder_upper, self.u[:,0] >= rudder_lower)
        elev_mask = np.logical_and(self.u[:,1] <= elev_upper, self.u[:,1] >= elev_lower)
        thrust_mask = np.logical_and(self.u[:,2] > 0.5, self.u[:,3] > 0.5)
        mask = np.logical_and(rudder_mask, elev_mask)
        mask = np.logical_and(mask, thrust_mask)
        return self.temp_filter(mask)


    def temp_filter(self, mask):
        x = self.x[mask]
        xdot = self.xdot[mask]
        u = self.u[mask]
        t = self.t[mask]
        accels = self.accels[mask]
        return x, xdot, u, t, accels

    def filter(self, mask):
        before = len(self.x)
        self.x = self.x[mask]
        self.xdot = self.xdot[mask]
        self.u = self.u[mask]
        self.t = self.t[mask]
        self.accels = self.accels[mask]
        after = len(self.x)
        print("Filtered from {} to {} pts".format(before, after))
        assert len(self.xyz) > 1, "No points left!"


    def reset_filters(self):
        self.x = np.copy(self.original_x)
        self.xdot = np.copy(self.original_xdot)
        self.u = np.copy(self.original_u)
        self.t = np.copy(self.original_t)
        self.accels = np.copy(self.original_accels)

    @property
    def xyz(self):
        return self.xdot[:,:3]

    @property
    def rpy(self):
        return self.xdot[:,3:]

    @property
    def xyz_accels(self):
        return self.accels[:,:3]

    @property
    def rpy_accels(self):
        return self.accels[:,3:]


def do_dim_reduc_clustering(X):
    from dim_reduc_clustering import DimReductionClustering

    # n_neighbors > reduction param, higher=global structure
    # min_pts > clustering param, higher=better for noisy
    model = DimReductionClustering(n_components=2, n_neighbors = 100, min_pts = 40, min_dist=0.01)
    print("Fitting...")
    t0 = time.time()
    model.fit(X, plot_elbow=False)
    print("Done in {}s".format(int(time.time()-t0)))
    model.display_plotly()
    return model


if __name__ == '__main__':
    from toolbox import plotting as pltn
    import matplotlib.pyplot as plt
    plt.rcParams['pdf.fonttype'] = 42
    import matplotlib.tri as mtri
    from mpl_toolkits.mplot3d import Axes3D #needed for '3d'
    plt.ion()

    np.set_printoptions(precision=4, floatmode='fixed', suppress=True)

    if len(sys.argv) < 2:
        print("Must pass a json file, generated by process_log")
        print("Using default file")
        filename = 'real_lolo_data.json'
    else:
        filename = sys.argv[-1]

    data = Dataset(filename, normalize_u=True, keep_underwater_only=True)


    if 'realify' in sys.argv:
        import pickle
        from sim_to_real import Realifier
        with open("realifier.pickle", 'rb+') as f:
            realifier = pickle.load(f)

        data.xdot[:,:3] = realifier.xform(data.xyz)


    # x, xdot, u, t, accels = data.get_maneuver(6)
    # X = xdot[:,:3]
    X = data.xyz


    from sklearn.cluster import DBSCAN
    dbscan = DBSCAN(eps=0.003, min_samples=60, n_jobs=-1)
    clustering = dbscan.fit(X)
    labels = clustering.labels_
    print("Num labels:{}".format(len(np.unique(labels))))

    # remove noise
    data.filter(labels >= 0)
    # labels[:] = 0

    # print("Filtering")
    # data.filter(data.u[:,0] == 0)
    # data.filter(data.u[:,1] == 0)
    # data.filter(data.u[:,2] > 0)
    # data.filter(data.u[:,3] > 0)

    # print("Plotting")
    # from process_log import set_axes_equal
    # fig = plt.figure(figsize=(10,10))
    # plt.axis('equal')
    # ax = fig.add_subplot(111, projection='3d')
    # ax.azim=45
    # ax.elev=30
    # pltn.scatter3(ax, data.xyz, alpha=0.3)
    # set_axes_equal(ax)
    # ax.set_xlabel("Forward speed")
    # ax.set_ylabel("Sideways speed")
    # ax.set_zlabel("Vertical speed")
    # plt.show()


    if 'plot' in sys.argv:
        use_data_ranges = 'real' in sys.argv
        try:
            win, app = plot_xyz(data.xyz, data.u, use_data_ranges=use_data_ranges, labels=labels)
        except:
            win, app = plot_xyz(data.xyz, data.u, use_data_ranges=use_data_ranges)
        sys.exit(app.exec())






